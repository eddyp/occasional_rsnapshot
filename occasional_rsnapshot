#!/bin/bash

RSNAPSHOT=${RSNAPSHOT:=/usr/bin/rsnapshot}


declare -A tsfmt
tsfmt[yearly]='+%Y'
tsfmt[monthly]='+%-m'
tsfmt[weekly]='+%W'
tsfmt[daily]='+%d'
tsfmt[hourly]='+%k'

# Parameters:
#   $1 = interval
# Uses:
#   $CONF
# test if the configuration requires the given type of interval
config_has_interval()
{

	grep -q "^\s*retain\s\s*$1" "$CONF"
}

# Parameters:
#   $1 = interval
# Uses:
#   $CONF
# returns the number of backups for the given type of interval
retain_count()
{
	grep "^\s*retain\s\s*$1" "$CONF" | sed "s#^.*$1\s*\([0-9]*\)#\1#"
}

# Parameters:
#   $1 = interval
# Uses:
#   $SROOT
# returns the interval name if a backup for the given interval is necessary
needs_interval()
{

	interval=$1

	# test if the configuration requires the given type of interval
	config_has_interval "$interval" || return 1

	fileint=$(ls -ctlp --time-style ${tsfmt[$interval]} "$SROOT" | grep "${interval}\.[0-9]*/" | head -n1 | tr -s ' ' | cut -f 6 -d ' ')
	if [ -z "$fileint" ] ;then
		echo "$interval"
		return
	else
		nowint=$( date "${tsfmt[$interval]}" )
		dif=$(( $nowint - $fileint ))

		[ $interval = 'hourly' ] && multiplier=$(( 24 / $(retain_count $interval) )) || multiplier=1
		[ $dif -lt $multiplier ] || echo "$interval"
	fi
}

# returns the intervals for which a backup must be made
# based on the configuration and the already existing backups
get_required_intervals ()
{
	possible_intervals="yearly monthly weekly daily hourly"
	local intervals
	local longest_needed=""

	for i in $possible_intervals ; do
		if [ "$longest_needed" ]; then
			config_has_interval $i && needs_it="$i" || needs_it=""
		else
			needs_it=$(needs_interval $i)
		fi
		intervals="$intervals $needs_it"
		[ "$longest_needed" ] || longest_needed="$needs_it"
	done

	echo $intervals
}

debug()
{
	[ "$DEBUG_OCCASIONAL_RSNAPSHOT" ] || return
	echo "DEBUG [$$]: $@" >&2
}

if [ $# -ne 1 ]; then
	cat <<EOHELP
This utility needs the rsnaphot confguration file as parameter.

Usage:

    $0 /path/to/rsnapshot.conf

  The script tries to find the snapshot_root based on the
  information in the configuration file, then, if found, it
  starts the appropriate backups that are detected as
  necessary since the last time the backup was made.

  If the script does not find the snapshot_root, it will
  terminate silently, since it assumes the drive is not
  connected.

  Because the script is silent by default when no drive is
  found, it makes it appropriate for placing in cron with a
  very high frequency as a means of triggering backups just by
  connecting the backup drive; no noise will be made in the
  cron emails when the srcipt does not find the backup drive
  connected.

EOHELP
	exit 1
fi

CONF="$1"
[ ! -f "$CONF" ] && echo "Configuration file '$CONF' not found." && exit 1 || true


SROOT=$(grep '^\s*snapshot_root\s' "$CONF" | sed 's#snapshot_root\s\s*##')
# if the backup destination does not exist, probably the disk is not mounted
[ -d "$SROOT" ] || exit 0

# we assume that if the lockfile is present, another rsnapshot
# is ongoing, so we  just exit silently not to cause noise in
# the cron mails
LOCKF=$(grep '^\s*lockfile\s' "$CONF" | sed 's#lockfile\s\s*##')
[ -f "$LOCKF" ] && exit 0

# Avoid the situation where two consecutive executions via cron
# synchronize in such a way that the later spawned occasional_rsnapshot
# inserts itself right between a larger interval and the lower next one
# from the first's execution.
# This can happen when using delayed removal of the oldest snapshot
# because the rsnapshot pid is removed at this point, but the
# occasional_rsnapshot script hasn't finished at this point.
# We avoid this situation by making our own lockfile.
OCCLOCKF=$(grep '^\s*lockfile\s' "$CONF" | sed -e 's#lockfile\s\s*##' -e 's#\(.pid\)*\s*$#.occasional.pid#')
OCCPIDD=$(dirname ${OCCLOCKF})
[ -d "${OCCPIDD}" ] || mkdir -p "${OCCPIDD}"
debug "Race for the lock!"
if [ -f "$OCCLOCKF" ]; then
	OCCPID=$(cat $OCCLOCKF)
	# check if the previous instance is alive
	if [ "$OCCPID" ] && ps -p $OCCPID -o comm= >/dev/null ; then
		exit 0
	fi
	[ "$OCCPID" ] && debug "Found stale occasional_rsnapshot PID file $OCCLOCKF." || true
fi
debug "Aquiring lock"
echo $$ | tr -d '\n' > $OCCLOCKF
# make sure we did aquire the lock
for wait in $(seq 3); do
	sleep $wait
	# did we aquire lock?
	grep -q $$ $OCCLOCKF || exit 0
done
debug "Got the lock!"
trap "[ -f "$OCCLOCKF" ] && grep -q $$ $OCCLOCKF 2>&1 >/dev/null && rm -f $OCCLOCKF" TERM INT EXIT


set -e

for i in $(get_required_intervals) ; do
	# sadly 'echo -n' is not portable, but I am too lazy to fix this
	# just for some pretty printing in the cron email.
	echo -n "Starting rsnapshot at interval $i... "
	${RSNAPSHOT} -c "$CONF" $i
	echo 'done.'
done

