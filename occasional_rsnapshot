#!/bin/bash

RSNAPSHOT=${RSNAPSHOT:=/usr/bin/rsnapshot}


declare -A min_int
min_int[yearly]=31536000 # 3600 * 24 * 365
min_int[monthly]=2592000 #3600 * 24 * 30
min_int[weekly]=604800 # 3600 * 24 * 7
min_int[daily]=86400 # 3600 * 24
min_int[hourly]=3600

declare -A nextint
nextint[yearly]=''
nextint[monthly]='yearly'
nextint[weekly]='monthly'
nextint[daily]='weekly'
nextint[hourly]='daily'

declare -A leints
leints[yearly]='yearly monthly weekly daily hourly'
leints[monthly]='monthly weekly daily hourly'
leints[weekly]='weekly daily hourly hourly'
leints[daily]='daily hourly'
leints[hourly]='hourly'

possible_intervals="yearly monthly weekly daily hourly"


# Parameters:
#   $1 = interval
# Uses:
#   $CONF
# test if the configuration requires the given type of interval
config_has_interval()
{

	grep -q "^\s*retain\s\s*$1" "$CONF"
}

# Parameters:
#   $1 = interval
# Uses:
#   $CONF
# returns the number of backups for the given type of interval
retain_count()
{
	grep "^\s*retain\s\s*$1" "$CONF" | sed "s#^.*$1\s*\([0-9]*\)#\1#"
}

# Parameters:
#   $1 = interval
# Uses:
#   $ROOT
# Returns:
#   the list of time stamps of the existing backups for the given
#   interval or empty string, if no backup exists
get_file_timestamps()
{
	local interval=$1
	local timestamps

	[ "$interval" ] || return

	timestamps="$(ls -utlp --time-style +%s "$SROOT" | grep "${interval}\.[0-9]*/" | tr -s ' ' | cut -f 6 -d ' ' | tr '\n' ' ')"
	# remove the trailing space
	timestamps="${timestamps% }"

	echo "$timestamps"
}

# Parameters:
#   $1 = interval
# Uses:
#   $SROOT
# returns the interval name if a backup for the given interval is necessary
#         if there is a backup gap relative to the next existing longer
#         interval, then it will print it repeatedly so the gap is closed.
#
#         example 1:
#           3 daily and 5 weekly intervals are configured;
#           there is no weekly backup on disk
#           result is: daily
#           effect: at the end daily.0 has the latest backup for dailies
#
#         example 2:
#           3 daily and 5 weekly intervals are configured;
#           there is a weekly.0 backup and only a daily.0 on disk
#           result is: daily daily
#           effect: at the end daily.0, daily.1 and daily.2 exist
needs_interval()
{
	# test if the configuration requires the given type of interval
	config_has_interval "$1" || return

	local interval=$1
	local repeats=0
	local retained=0
	local wantoretain="$(retain_count) $interval"
	local target=0
	local min_passed=${min_int[$interval]}

	# hourly is not ran once/hour, unlike other intervals
	# we want to check if the minimum number of hours has passed, if we evaluate hourly
	[ "$interval" != "hourly" ] || min_passed=$(( ${min_int[daily]} / ${wantoretain} ))


	timestamps="$(get_file_timestamps $interval)"
	# XXX: don't invoke subshell
	retained="$(echo $timestamps | wc -w)"

	# If there is a backup for the next interval, we want fill up the current interval.
	# Otherwise, a single backup is perfectly fine
	[ "$( get_file_timestamps ${nextint[$interval]} )" ] && target="$wantoretain" || target=1
	# We check if there is a gap between the targeted number of backups
	# and the actual situation on disk.
	# If there is, we adjust the repeats accordingly.
	# If there is no gap, we should backup once or not all (decided later).
	repeats=$(( $target - $retained ))
	[ "$repeats" -ge 1 ] || repeats=1

	if [ $retained -gt 0 ] ; then
		nowint=$( date "+%s" )
		fileint="${timestamps%% *}"
		dif=$(( $nowint - $fileint ))


		# has the interval passed?
		[ $dif -lt $min_passed ] && repeats=0 || true
	fi


	# give the response
	answer=''
	for i in $(seq $repeats) ; do
		answer="$answer $interval"
	done
	echo ${answer# }
}

# returns a list with all intervals equal or less than the given interval
get_intervals_le_than()
{
	[ "$1" ] || return 2

	local interval=$1

	local i
	local r=''
	local on=no

	for i in $possible_intervals ; do
		if [ "$on" = "yes" ] || [ "$interval" = "$i" ] ; then
			on=yes
			r="$r $i"
		fi
	done

	echo $r

}

# returns the intervals for which a backup must be made
# based on the configuration and the already existing backups
get_required_intervals ()
{
	local intervals=''
	local longest_needed=""

	for i in $possible_intervals ; do
		if config_has_interval $i ; then
			if interval_gap $i ; then
				intervals="$intervals ${leints[$i]}"
			fi
		fi
	done

	echo $intervals
}

debug()
{
	[ "$DEBUG_OCCASIONAL_RSNAPSHOT" ] || return
	echo "DEBUG [$$]: $@" >&2
}

if [ $# -ne 1 ]; then
	cat <<EOHELP
This utility needs the rsnaphot confguration file as parameter.

Usage:

    $0 /path/to/rsnapshot.conf

  The script tries to find the snapshot_root based on the
  information in the configuration file, then, if found, it
  starts the appropriate backups that are detected as
  necessary since the last time the backup was made.

  If the script does not find the snapshot_root, it will
  terminate silently, since it assumes the drive is not
  connected.

  Because the script is silent by default when no drive is
  found, it makes it appropriate for placing in cron with a
  very high frequency as a means of triggering backups just by
  connecting the backup drive; no noise will be made in the
  cron emails when the srcipt does not find the backup drive
  connected.

EOHELP
	exit 1
fi

CONF="$1"
[ ! -f "$CONF" ] && echo "Configuration file '$CONF' not found." && exit 1 || true


SROOT=$(grep '^\s*snapshot_root\s' "$CONF" | sed 's#snapshot_root\s\s*##')
# if the backup destination does not exist, probably the disk is not mounted
[ -d "$SROOT" ] || exit 0

# we assume that if the lockfile is present, another rsnapshot
# is ongoing, so we  just exit silently not to cause noise in
# the cron mails
LOCKF=$(grep '^\s*lockfile\s' "$CONF" | sed 's#lockfile\s\s*##')
[ -f "$LOCKF" ] && exit 0

# Avoid the situation where two consecutive executions via cron
# synchronize in such a way that the later spawned occasional_rsnapshot
# inserts itself right between a larger interval and the lower next one
# from the first's execution.
# This can happen when using delayed removal of the oldest snapshot
# because the rsnapshot pid is removed at this point, but the
# occasional_rsnapshot script hasn't finished at this point.
# We avoid this situation by making our own lockfile.
OCCLOCKF=$(grep '^\s*lockfile\s' "$CONF" | sed -e 's#lockfile\s\s*##' -e 's#\(.pid\)*\s*$#.occasional.pid#')
OCCPIDD=$(dirname ${OCCLOCKF})
[ -d "${OCCPIDD}" ] || mkdir -p "${OCCPIDD}"
debug "Race for the lock!"
if [ -f "$OCCLOCKF" ]; then
	OCCPID=$(cat $OCCLOCKF)
	# check if the previous instance is alive
	if [ "$OCCPID" ] && ps -p $OCCPID -o comm= >/dev/null ; then
		exit 0
	fi
	[ "$OCCPID" ] && debug "Found stale occasional_rsnapshot PID file $OCCLOCKF." || true
fi
debug "Aquiring lock"
echo $$ | tr -d '\n' > $OCCLOCKF
# make sure we did aquire the lock
for wait in $(seq 3); do
	sleep $wait
	# did we aquire lock?
	grep -q $$ $OCCLOCKF || exit 0
done
debug "Got the lock!"
trap "[ -f "$OCCLOCKF" ] && grep -q $$ $OCCLOCKF 2>&1 >/dev/null && rm -f $OCCLOCKF" TERM INT EXIT


set -e

for i in $(get_required_intervals) ; do
	# sadly 'echo -n' is not portable, but I am too lazy to fix this
	# just for some pretty printing in the cron email.
	echo -n "Starting rsnapshot at interval $i... "
	${RSNAPSHOT} -c "$CONF" $i
	echo 'done.'
done

